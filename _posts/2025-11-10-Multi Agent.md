---
layout: post
title:  "多智能体探索分析"
date:   2025-11-10 11:00:00 +0800--
toc: true  
toc_sticky: true  
categories: [技术杂谈]
tags:   [MultiAgent]
---
### 写在前面：

垂域落地路线（金融多轮对话）：

•M1：单域RAG + 工具试算，Chain主路径 + 审核守门；LangGraph可视化与回放

•M2：引入Planner-Executor与反思；逐句引用核对；对抗样本与Schema异常注入

•M3：Teacher–Student在线旁路评测与Bandit路由；大/小模型双轮驱动

•M4：多域路由、合规知识图谱融合、全面SLA治理与成本优化

业界三种主流的多智能体架构类型：

•**层级式（管理者-工作者）**

•**顺序式（基于链）**

•**协作式（基于图）**

高级 AI 应用的演进路径：

•从为**单个代理**配备**工具**开始（工具扩充模式）；

•进而为代理增加**计划能力**以处理复杂任务（计划-任务-执行器模式）；

•最终发展到由**多个专业代理**组成团队**协同工作**（多代理协作模式）。

### 多智能体概念框架
#### 核心概念

![图1](/images/post251110/img.png)

每个智能体由作为神经处理器的语言模型 m、当前目标 o、环境 e、输入感知 x 和相应的输出/行动 y 组成。核心焦点是协作渠道 C，它促进了智能体之间的协调和编排。

这些渠道由其参与者（所涉及的智能体）、类型、结构和策略来定义。

可分为几类：

![图2](/images/post251110/img1.png)

每个智能体 a 通过其系统提示 r 配备了不同的工具或能力。

•在场景 a) 中，智能体通过利用各自的专长（例如，写作、翻译、研究）进行合作，以实现一个共同的目标（学术写作）。

•在场景 b) 中，智能体为了各自的目标而相互竞争和辩论。

•在场景 (c) 的“竞合”（coopetition）关系中，智能体相互妥协，在某个方面竞争，而在另一个方面达成一致。

Agent之间通信方式：

![图3](/images/post251110/img2.png)

•图 (a)，展示了中心化结构，该结构可被分为两种类型。

◦在第一种类型中，大语言模型（LLM）驻留在分布式智能体上，以 FedIT 为例。

◦在第二种类型中，大语言模型托管在一个中央智能体上，以 AutoAct 为例。

•图 (b)，描绘了去中心化结构，以 AgentCF 为例。

•图 (c)，代表了层级式结构，以 CAMEL 架构为例。

#### 核心技术组件


|   |   |   |   |
|---|---|---|---|
|组件|中心化编排 (Orchestration)|去中心化协作 (Choreography)|混合架构 (Hybrid)|
|**控制流**|严格中心化，串行为主|完全去中心化，事件驱动|中心化规划，去中心化执行|
|**Planning**|由中心控制器负责|分布式，各智能体自规划|**核心组件**。由一个专用Planner生成结构化计划（如DAG图）|
|**Memory**|集中在中心控制器|分布在各个智能体或共享工作区|**分层记忆**。包括全局共享Memory和智能体私有Memory|
|**通信**|中心与控制点对点通信|智能体间通过广播或共享状态通信|通过中心路由进行消息传递，高效且可追踪|
|**功能表现**|任务逻辑简单清晰|高度灵活，能涌现复杂行为|**平衡了功能性和复杂性**，最适合商业应用|
|**性能表现**|中心节点易成瓶颈|扩展性好，但冗余计算多|**性能最优**，支持并行执行，效率高|
|**调试难度**|容易|非常困难|中等（借助可视化工具，如LangGraph）|

#### 应用场景
来自AutoGen:

![图4](/images/post251110/img3.png)

一个示例：

![图5](/images/post251110/img4.png)

### 架构类型
#### 常见的多智能体架构类型
##### 链式编排（Chain / Pipeline）
•核心概念：固定顺序节点，上一环输出即下一环输入；线性流水线。

•流程示例：输入 → 预处理 → 检索 → 生成 → 审核 → 输出。

•优点：简单、可预测、低延迟、易上线与观测。

•局限：条件分支/循环困难；跨回合状态与错误恢复较弱。

•代表：LangChain Chains、LlamaIndex/Haystack Pipelines、SequentialChain。

•适用：简单到中等复杂度、路径稳定的任务。

##### 计划-执行/层级式（Planner–Executor / Manager–Worker）
•核心概念：中心规划器生成子任务序列或子目标图；分派给执行者；可迭代再规划。

•流程示例：用户目标 → Planner 拆解 → Worker 执行（检索/工具/生成）→ 汇总与修订。

•优点：任务分解清晰，覆盖复杂目标；自然支持“专家协作”与再规划。

•局限：计划质量依赖模型；长对话中易计划漂移；需可执行性与回退机制。

•代表：ReAct、Plan-and-Execute、AutoGen Planner/Executor、CrewAI（Leader/Workers）、LLM-as-Planner。

•适用：复杂任务、多工具协同、需要显式计划的业务。
##### 图/状态机（Graph / Stateful Orchestration）
•核心概念：节点=代理或功能；边=条件转移；共享状态对象贯穿全局；支持循环/分支/并发/重试。

•流程特征：状态驱动、动态路由；失败可重试/补偿；可灰度与回放。

•优点：最强控制力与可观测性；工程化与SLA友好。

•局限：建模与维护成本高；需良好的状态与运维体系。

•代表：LangGraph、Semantic Kernel Orchestration、Temporal/Argo + LLM。

•适用：高复杂度多轮对话、强合规/强SLA生产环境。
##### 黑板/共享内存（Blackboard / Workspace）
•核心概念：各代理在共享黑板发布/消费中间结果与证据；调度器或事件驱动唤醒。

•优点：松耦合、易扩展、并发贡献友好；中间证据显式化，利于解释与回放。

•局限：一致性与冲突解决复杂；需额外审计与锁策略。

•代表：AutoGen（GroupChat + Shared Memory）、研究型黑板系统、OpenDevin风格工作台。

•适用：证据逐步汇聚、探索式协作。
##### 群体协作/市场机制（Swarm / Cooperative / Auction）
•核心概念：多代理并行探索，竞标或投票/融合；路由器/仲裁器选择最优。

•优点：鲁棒性高、覆盖多策略；并行加速。

•局限：成本高，融合与一致性复杂，确定性弱。

•代表：Mixture-of-Agents、AutoGen 多代理对话、Router-Mix 研究范式。

•适用：方案多样性重要、需要容错和探索的场景。
##### 辩论-裁判/宪法式（Debate / Critic / Constitutional）
•核心概念：多“辩手”提出方案，Critic/Referee 按规则/宪法评审并修订，直至通过门槛。

•优点：质量与安全显著提升；适合高风险领域。

•局限：时延与成本上升；裁判标准与提示需维护。

•代表：Anthropic Constitutional AI（Critique-and-Revise）、Self-Refine、LLM-as-Judge。

•适用：金融/医疗/法务等高审慎输出。
##### 工具中心/MCP（Tool-centric / Function-calling / MCP）
•核心概念：工具为第一公民；代理完成意图识别→参数构造→工具编排→结果解释。

•优点：与现有系统集成顺滑；权限与审计边界清晰；可治理。

•局限：强依赖工具契约、参数验证、回滚/补偿与幂等。

•代表：OpenAI/Anthropic Function Calling、MCP（Model Context Protocol）、LangChain Tools、SK Plugins。

•适用：系统自动化、业务办理、数据/交易类强工具任务。
#### 多Agent编排方式
##### 顺序业务流程 (Sequential Orchestration)

![图6](/images/post251110/img5.png)

这是最直接的一种多代理协作方式，类似于工厂里的流水线。

•**核心理念**：将一个复杂的任务分解成多个连续的阶段，每个阶段由一个专门的代理负责。前一个代理的输出直接作为后一个代理的输入。

•**工作流程**：

◦任务从第一个代理开始。

◦该代理完成后，将其结果传递给第二个代理。

◦第二个代理基于收到的结果继续工作，然后传递给第三个代理，以此类推。

◦整个过程呈线性，按预定顺序依次执行，直到最后一个代理完成最终任务。

•**文档中的例子**：构建一个“自动化编码和测试”流程。

1.`程序员代理`接收需求并编写代码。

2.`测试工程师代理`接收代码，为其编写单元测试。

3.`测试执行代理`运行这些测试，并报告结果。

•**适用场景**：流程固定、步骤有明确前后依赖关系的复杂任务。

##### 并发业务流程 (Concurrent Orchestration)

![图7](/images/post251110/img6.png)

当任务的某些部分可以被独立、并行处理时，采用并发模式可以显著提高效率。

•**核心理念**：将任务中可以并行执行的部分分派给不同的代理，让它们同时工作，最后再将它们的结果汇总。

•**工作流程**：

◦编排器识别出可以并行处理的子任务。

◦同时启动多个不同的代理，每个代理负责一个子任务。

◦等待所有并发执行的代理都完成后，收集它们各自的输出。

◦由一个“聚合代理”或编排器将这些分散的结果合并，形成一个统一的、完整的最终答案。

•**文档中的例子**：回答“比较苹果和微软的最新收益公告”这个问题。

1.编排器同时启动两个代理。

2.`代理 A`负责查找并分析苹果公司的收益报告。

3.`代理 B`负责查找并分析微软公司的收益报告。

4.当 A 和 B 都完成后，`聚合代理`将两份分析报告进行比较和总结，得出最终答案。

•**适用场景**：任务可以被分解为多个互不依赖的子任务，通过并行处理来缩短总耗时。
##### 群聊业务流程 (Group Chat Orchestration)

![图8](/images/post251110/img7.png)

这是最灵活、最动态但也最复杂的协作方式，它模拟了一个人类团队围绕一个问题进行开放式讨论和协作的过程。

•**核心理念**：所有代理都在一个共享的“聊天室”或上下文中进行交流。每个代理都可以看到其他代理的发言，并根据对话的进展决定自己何时以及如何介入。

•**工作流程**：

◦一个“管理员”或“元代理”发起群聊，并引入初始问题或任务。

◦所有专家代理都“监听”对话。

◦代理可以自主决定发言，或者由管理员根据需要“点名”某个代理发言。

◦对话持续进行，直到管理员判断任务已经完成或达到了预设的终止条件。

•**文档中的例子**：一个包含`命令代理`、`文本编写代理`、`安全代理`等的群聊。

1.`命令代理`从用户那里接收指令。

2.它可能会调用`文本编写代理`来草拟回复。

3.`安全代理`会审查草拟的回复，确保其不包含敏感信息。

4.整个过程在共享的聊天记录中进行，所有代理都可见。

•**适用场景**：需要多个专家进行动态、迭代式讨论才能解决的、没有固定流程的复杂问题。这是最有潜力但也最难控制的模式。

### 垂域多轮对话场景
垂域场景实现的路径，是一个重要课题。比如，以金融场景为例，
#### 参考架构
###### 角色与职责
•Router/Classifier：意图识别与风险分级。

•Planner：跨回合任务分解与步骤维护。

•RAG Agent：政策/产品/研究报告检索与证据聚合。

•Tool Agent：受权工具调用（账户查询、下单、转账、支付、额度调整等）。

•Critic/Compliance：合规、风险与安全审计（宪法/规则+模型判定）。

•Memory Manager：会话记忆、用户画像、会话态（交易上下文）。

•Orchestrator（LangGraph）：状态机驱动转移、超时/重试/补偿、灰度。
###### 状态与内存（Memory）
•短期对话记忆：最近 N 轮消息与摘要。

•长期业务态：用户ID/权限、风险等级、会话交易单、签名/授权状态。

•检索记忆：证据片段与来源元数据（doc_id、版本、时间）。

•运行时统计：尝试次数、工具返回码、fallback 标志。

•存储：Redis（会话态）、向量库（Milvus/PGV）用于 RAG、关系库存审计与订单。
###### 工具与安全
•工具契约：严格的 JSON Schema/参数验证、幂等ID、时序约束。

•权限：细粒度 RBAC/ABAC，工具级令牌，业务白名单。

•安全闸：PII 脱敏、Prompt 注入防御、意图黑/白名单、金额/风险阈值强审。

•审计：每次工具调用均关联会话、代理、模型版本、参数回显与签名。
###### 推荐控制流（LangGraph 为基座）
Router → Planner →  RAG（若查询）/Tool（若操作）→  Critic/Compliance → 
用户确认/签名 →  执行与回执→ 异常分支：重试/回滚/人工接管。

#### 多智能实现路径
•低复杂度、强SLA入口：链式编排作为主路径（快），加“失败→图节点回退”保障。

•中高复杂度任务：计划-执行作为核心范式；配合图/状态机显式化路由、超时、重试与合规守门。

•高风险合规输出：在关键节点引入辩论/裁判或宪法式自检；引用对齐与适当性校验必备。

•工具密集型：以工具中心（或MCP）规范接入账户/账单/额度/下单等API，参数澄清与幂等缓存。

•协作创作/证据汇聚：引入黑板共享证据与中间结论，便于回放与审计。

###### 推荐架构
Planner–Executor + 审核者（Supervisor）+ RAG与工具的双轨，并以LangGraph/Temporal做可视化DAG与回放。

•路由/入口

    ◦意图识别与权限校验（Router + Policy Guard）

•规划（Planner）

    ◦任务分解：是否需要检索？是否需要调用额度/账单/还款试算工具？

    ◦计划包含：子目标、所需证据、工具序列、合规模板

•执行（Executors）

    ◦Retrieval Agent：查询改写、召回、重排、去重、时间过滤

    ◦Tool Agent：调用账单/交易/额度/利率API；带重试与熔断

    ◦Writer Agent：结构化答复、带引用与免责声明

•审核（Supervisor/Validator）

    ◦合规/适当性检查、引用对齐、敏感词、禁语、拒答策略

•反思（Reflector，可选）

    ◦若验证失败，触发再检索/再生成，限次与预算

•记忆（Memory）

    ◦会话短期记忆（槽位/实体）、长期用户画像（权限受控）

    ◦证据黑板：本轮使用的来源、工具结果、风险点

•评测与治理（Agentic Eval）

    ◦节点级指标、端到端任务成功率、合规命中率、成本/时延分解

    ◦教师-学生奖励闭环（见结尾建议）

功能表现与性能取舍：

    •质量优先路径：引入反思+审核，准确率/合规显著提升，但时延上升（适合高价值对话或人工在环）

    •速度优先路径：直出或轻检索，低延迟低成本，但对复杂问法与合规边界敏感

    •自适应策略：按意图/风险等级动态选择路径（Mixture-of-Policies）


- 一个典型对话任务流示例（额度调整试算）：

        1.Router判为“额度调整”，风险中等 → 走Planner Lane。

        2.Planner生成步骤：收集必要参数 → 账户权限校验 → 工具试算 → RAG匹配政策 → 生成答复 → 合规校验。

        3.Clarifier 追问缺失参数（如账龄、收入证明状态）。

        4.Tool Agent 调用“额度试算API”（重试/幂等）并返回可行区间。

        5.RAG 召回“额度调整政策/材料清单”，产出引用片段。

        6.Writer 生成答复：给出可行区间、所需材料、办理路径与时效；附引用与免责声明。

        7.Compliance Guard 校验禁语、逐句证据对齐；失败→Refine一次。

        8.Supervisor 终审并输出；若工具失败达到阈值 → 降级为“人工协助工单”。

### 框架与平台对比
#### 框架对比


|   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|
|框架|架构重心|Memory/State|Planning/路由|工具 & 生态|并发/容错|生产成熟度|
|LangChain|组件生态+Chains/Agents|会话/摘要，传参为主|ReAct/Plan‑and‑Execute 可用|Tools 丰富，RAG/评测齐全|需自建重试/补偿|成熟，入门低|
|LangGraph|状态机/图编排|显式全局 State|节点路由/条件边|复用 LangChain 工具|原生循环/分支/回放|强烈推荐做编排基座|
|AutoGen|多代理对话/回合管理|会话上下文为主|Planner/GroupChat|工具/代码执行友好|以对话为中心，容错一般|研究/原型强，生产需加固|
|CrewAI|Leader‑Worker 协作|任务态/上下文|Leader 统筹|与 LangChain/LlamaIndex 兼容|需二次开发补齐|快速搭团队式原型|
|LlamaIndex|RAG/路由|索引/记忆强|Router/Query Graph|文档/RAG最强项|结合工作流可用|做知识问答佳|
|Semantic Kernel|Orchestration/Planner|Memory/技能库|Planner/技能选择|.NET/企业集成强|结合企业中间件|金融 IT 生态友好|
|Anthropic（Claude+MCP）|宪法/批判/工具|会话/上下文|Critique‑and‑Revise/Computer Use|MCP 标准化工具|安全对齐强|做合规与安全闸极佳|

注：Anthropic并非“成套编排框架”，但其 Constitutional/Critic 模式、MCP 工具生态、Computer Use 能力非常适合充当“安全裁判+工具标准化”的关键组件。

展开如下：

•LangChain

    ◦优势：工具生态丰富、Chains/Agents齐全、社区样例多

    ◦局限：复杂多Agent状态与可视化有限；生产回放/灰度需自建

    ◦适合：快速原型、丰富工具对接

•LangGraph

    ◦优势：图式状态机编排、显式状态/边条件、易回放与可视化；适合多Agent协作与反思回路

    ◦局限：对企业级审计/多租治理需自扩展

    ◦适合：生产级多Agent的DAG/状态机落地

•AutoGen

    ◦优势：多Agent对话协作、组聊范式、共享记忆；实验性强

    ◦局限：强场景治理/SLA能力不足；对合规严苛场景需加强守门

    ◦适合：协作生成、研究与PoC

•Anthropic 多Agent/MCP

    ◦优势：MCP规范化工具接入与权限边界；Constitutional AI便于合规守护与反思修正

    ◦局限：生态锁定、对本地工具与私域集成需要适配

    ◦适合：强工具编排、安全边界清晰的企业落地

•Temporal/Argo + LLM

    ◦优势：企业级编排、重试/补偿/可溯；与服务网格/观测系统良好集成

    ◦局限：需要自建LLM适配层；开发复杂度高

    ◦适合：强SLA/强审计/强合规的生产环境

•DSPy

    ◦优势：面向“策略学习”的可编程提示与自动调参；易做Teacher–Student

    ◦局限：对大规模编排与可视化较弱

    ◦适合：研究与离线策略优化

组合建议（金融场景）：

    •编排：LangGraph/Temporal 负责DAG与状态

    •能力：LangChain工具层 + Anthropic MCP规范化关键工具

    •学习：DSPy/自研Eval引擎做Teacher–Student与参数调优

    •观测：OpenTelemetry + ClickHouse/ELK；评测与回放平台自建

#### 展开：LangGraph

•_LangGraph_ 是一种以“图（graph）”为中心的方式来构建、可视化和运行基于大语言模型（LLM）的应用和数据流的框架/工具集（注意：不同社区或公司对“LangGraph”命名的实现可能不同，下面是对常见图化 LLM 平台/框架的一般性总结）。

•核心理念是把 LLM 应用拆成节点（node）和边（edge）：节点表示模型调用、数据处理、检索器、工具接口等；边表示数据或控制流。通过图可以直观组合、复用与监控整个流程。

核心概念（常见）

    •节点（Node）：图中的基本单元，例如 prompt 模板节点、调用 OpenAI/Anthropic/HF 模型的节点、向量检索器节点、工具/API 调用节点、数据清洗节点等。

    •边/流（Edge/Flow）：节点间的数据传递或控制依赖，定义执行顺序或并行关系。

    •组件/模块（Component）：可复用的子图或组件，便于封装常见子流程（如 RAG 流程、对话管理器）。

    •执行器（Executor/Runtime）：负责运行图，调度节点、管理并发、处理错误与重试。

    •连接器（Connectors/Integrations）：与外部系统对接的适配器，例如向量数据库（FAISS, Pinecone, Weaviate）、存储、第三方 API、模型提供商等。

    •可视化界面：许多 LangGraph 风格的工具带可视化编辑器，用拖拽方式构建图、调试和观察执行日志。

典型功能与特性

    •可视化编排：图形化编辑器，支持拖拽、连线、参数化 prompt。

    •可重用与参数化：将常见子流程封装为组件并复用。

    •多模型/多后端支持：能切换不同 LLM 提供商与本地模型。

    •集成检索增强生成（RAG）：内置或易于接入向量检索器与文档管道。

    •版本与审计：记录图的版本、执行历史与输入/输出用于可观测性与回溯。

    •并行/异步执行：对多步、并发请求有执行优化。

    •插件/扩展：支持自定义节点或运行时扩展以对接业务系统。

预构建模版：

![图9](/images/post251110/img8.png)

LangGraph RAG框架：

![图10](/images/post251110/img9.png)

参考：

﻿[https://arxiv.org/abs/2501.06322](https://arxiv.org/abs/2501.06322)﻿

﻿[https://learn.microsoft.com/en-us/azure/architecture/ai-ml/guide/ai-agent-design-patterns](https://learn.microsoft.com/en-us/azure/architecture/ai-ml/guide/ai-agent-design-patterns)﻿

﻿[https://microsoft.github.io/autogen/0.2/docs/Use-Cases/agent_chat/#diverse-applications-implemented-with-autogen](https://microsoft.github.io/autogen/0.2/docs/Use-Cases/agent_chat/#diverse-applications-implemented-with-autogen)﻿

﻿[https://www.langchain.com/langgraph](https://www.langchain.com/langgraph)﻿

﻿[https://aistudio.baidu.com/blog/detail/735344982974341](https://aistudio.baidu.com/blog/detail/735344982974341)